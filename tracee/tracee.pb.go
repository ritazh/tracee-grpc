// Code generated by protoc-gen-go. DO NOT EDIT.
// source: tracee.proto

package tracee

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// Traces are mostly system calls performed by the processes
// and events, such as capabilities required to perform the actions requested by the process
type Trace struct {
	Event                string   `protobuf:"bytes,1,opt,name=event,proto3" json:"event,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Trace) Reset()         { *m = Trace{} }
func (m *Trace) String() string { return proto.CompactTextString(m) }
func (*Trace) ProtoMessage()    {}
func (*Trace) Descriptor() ([]byte, []int) {
	return fileDescriptor_08410d163fe16098, []int{0}
}

func (m *Trace) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Trace.Unmarshal(m, b)
}
func (m *Trace) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Trace.Marshal(b, m, deterministic)
}
func (m *Trace) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Trace.Merge(m, src)
}
func (m *Trace) XXX_Size() int {
	return xxx_messageInfo_Trace.Size(m)
}
func (m *Trace) XXX_DiscardUnknown() {
	xxx_messageInfo_Trace.DiscardUnknown(m)
}

var xxx_messageInfo_Trace proto.InternalMessageInfo

func (m *Trace) GetEvent() string {
	if m != nil {
		return m.Event
	}
	return ""
}

// A Result is received in response to a RecordTrace rpc.
type Result struct {
	Message              string   `protobuf:"bytes,1,opt,name=message,proto3" json:"message,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Result) Reset()         { *m = Result{} }
func (m *Result) String() string { return proto.CompactTextString(m) }
func (*Result) ProtoMessage()    {}
func (*Result) Descriptor() ([]byte, []int) {
	return fileDescriptor_08410d163fe16098, []int{1}
}

func (m *Result) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Result.Unmarshal(m, b)
}
func (m *Result) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Result.Marshal(b, m, deterministic)
}
func (m *Result) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Result.Merge(m, src)
}
func (m *Result) XXX_Size() int {
	return xxx_messageInfo_Result.Size(m)
}
func (m *Result) XXX_DiscardUnknown() {
	xxx_messageInfo_Result.DiscardUnknown(m)
}

var xxx_messageInfo_Result proto.InternalMessageInfo

func (m *Result) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func init() {
	proto.RegisterType((*Trace)(nil), "tracee.Trace")
	proto.RegisterType((*Result)(nil), "tracee.Result")
}

func init() { proto.RegisterFile("tracee.proto", fileDescriptor_08410d163fe16098) }

var fileDescriptor_08410d163fe16098 = []byte{
	// 131 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe2, 0xe2, 0x29, 0x29, 0x4a, 0x4c,
	0x4e, 0x4d, 0xd5, 0x2b, 0x28, 0xca, 0x2f, 0xc9, 0x17, 0x62, 0x83, 0xf0, 0x94, 0x64, 0xb9, 0x58,
	0x43, 0x40, 0x2c, 0x21, 0x11, 0x2e, 0xd6, 0xd4, 0xb2, 0xd4, 0xbc, 0x12, 0x09, 0x46, 0x05, 0x46,
	0x0d, 0xce, 0x20, 0x08, 0x47, 0x49, 0x89, 0x8b, 0x2d, 0x28, 0xb5, 0xb8, 0x34, 0xa7, 0x44, 0x48,
	0x82, 0x8b, 0x3d, 0x37, 0xb5, 0xb8, 0x38, 0x31, 0x3d, 0x15, 0xaa, 0x02, 0xc6, 0x35, 0xb2, 0xe2,
	0x62, 0x03, 0x1b, 0x91, 0x2a, 0x64, 0xc0, 0xc5, 0x1d, 0x94, 0x9a, 0x9c, 0x5f, 0x94, 0x02, 0x31,
	0x92, 0x57, 0x0f, 0x6a, 0x25, 0x98, 0x2b, 0xc5, 0x07, 0xe3, 0x42, 0x4c, 0x54, 0x62, 0xd0, 0x60,
	0x4c, 0x62, 0x03, 0xbb, 0xc6, 0x18, 0x10, 0x00, 0x00, 0xff, 0xff, 0x2d, 0xbf, 0xcc, 0xc4, 0x9d,
	0x00, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// TraceeClient is the client API for Tracee service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type TraceeClient interface {
	// A client-to-server streaming RPC.
	//
	// Accepts a stream of traces of newly created containers or processes
	RecordTrace(ctx context.Context, opts ...grpc.CallOption) (Tracee_RecordTraceClient, error)
}

type traceeClient struct {
	cc *grpc.ClientConn
}

func NewTraceeClient(cc *grpc.ClientConn) TraceeClient {
	return &traceeClient{cc}
}

func (c *traceeClient) RecordTrace(ctx context.Context, opts ...grpc.CallOption) (Tracee_RecordTraceClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Tracee_serviceDesc.Streams[0], "/tracee.Tracee/RecordTrace", opts...)
	if err != nil {
		return nil, err
	}
	x := &traceeRecordTraceClient{stream}
	return x, nil
}

type Tracee_RecordTraceClient interface {
	Send(*Trace) error
	CloseAndRecv() (*Result, error)
	grpc.ClientStream
}

type traceeRecordTraceClient struct {
	grpc.ClientStream
}

func (x *traceeRecordTraceClient) Send(m *Trace) error {
	return x.ClientStream.SendMsg(m)
}

func (x *traceeRecordTraceClient) CloseAndRecv() (*Result, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(Result)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// TraceeServer is the server API for Tracee service.
type TraceeServer interface {
	// A client-to-server streaming RPC.
	//
	// Accepts a stream of traces of newly created containers or processes
	RecordTrace(Tracee_RecordTraceServer) error
}

// UnimplementedTraceeServer can be embedded to have forward compatible implementations.
type UnimplementedTraceeServer struct {
}

func (*UnimplementedTraceeServer) RecordTrace(srv Tracee_RecordTraceServer) error {
	return status.Errorf(codes.Unimplemented, "method RecordTrace not implemented")
}

func RegisterTraceeServer(s *grpc.Server, srv TraceeServer) {
	s.RegisterService(&_Tracee_serviceDesc, srv)
}

func _Tracee_RecordTrace_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(TraceeServer).RecordTrace(&traceeRecordTraceServer{stream})
}

type Tracee_RecordTraceServer interface {
	SendAndClose(*Result) error
	Recv() (*Trace, error)
	grpc.ServerStream
}

type traceeRecordTraceServer struct {
	grpc.ServerStream
}

func (x *traceeRecordTraceServer) SendAndClose(m *Result) error {
	return x.ServerStream.SendMsg(m)
}

func (x *traceeRecordTraceServer) Recv() (*Trace, error) {
	m := new(Trace)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _Tracee_serviceDesc = grpc.ServiceDesc{
	ServiceName: "tracee.Tracee",
	HandlerType: (*TraceeServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "RecordTrace",
			Handler:       _Tracee_RecordTrace_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "tracee.proto",
}
